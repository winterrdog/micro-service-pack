# upstream pools for Service A and Service B (2 instances each)
upstream service_a {
    # use round-robin by default
    server app_a1:3000 max_fails=3 fail_timeout=10s;
    server app_a2:3000 max_fails=3 fail_timeout=10s;

    # keepalive helps connection reuse
    keepalive 16;
}
upstream service_b {
    server app_b1:4000 max_fails=3 fail_timeout=10s;
    server app_b2:4000 max_fails=3 fail_timeout=10s;
    keepalive 16;
}

# HTTP to HTTPS redirect
server {
    listen 80;
    server_name _;

    # add simple rate limiting on the redirect, as well
    limit_req zone=ip_rate burst=20 nodelay;
    return 301 https://$host$request_uri;
}

# TLS server for both services (SNI + routing by path)
server {
    listen 443 ssl http2;
    server_name services.local;   # change to your hostname or use _ for catch-all

    # shared ssl params
    include /etc/nginx/ssl-params.conf;

    # access logging per-site
    access_log /var/log/nginx/services_access.log main;
    error_log  /var/log/nginx/services_error.log warn;

    # global rate limiting (applies to all proxied locations unless overridden)
    limit_req zone=ip_rate burst=20 nodelay;

    # health-check endpoints that nginx can call to verify upstream responsiveness.
    # These proxy to upstream /health endpoints
    location = /health/service_a {
        proxy_pass http://service_a/health;
        proxy_connect_timeout 1s;
        proxy_read_timeout 2s;
        proxy_send_timeout 2s;
        proxy_next_upstream error timeout http_502 http_503 http_504;
    }
    location = /health/service_b {
        proxy_pass http://service_b/health;
        proxy_connect_timeout 1s;
        proxy_read_timeout 2s;
        proxy_send_timeout 2s;
        proxy_next_upstream error timeout http_502 http_503 http_504;
    }

    # Service A API (example path /a/)
    location /a/ {
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;

        proxy_http_version 1.1;
        proxy_set_header Connection "";

        # trailing slash strips /a/ prefix, so /a/docs becomes /docs
        proxy_pass http://service_a/;
        proxy_connect_timeout 3s;
        proxy_send_timeout 10s;
        proxy_read_timeout 30s;
        proxy_next_upstream error timeout http_502 http_503 http_504;

        # per-location rate limit (re-apply to be explicit)
        limit_req zone=ip_rate burst=10 nodelay;

        # caching headers
        add_header X-Proxy-Upstream $upstream_addr;
    }

    # Service B API (example path /b/)
    location /b/ {
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;

        proxy_http_version 1.1;
        proxy_set_header Connection "";

        # trailing slash strips /b/ prefix, so /b/docs becomes /docs
        proxy_pass http://service_b/;
        proxy_connect_timeout 3s;
        proxy_send_timeout 10s;
        proxy_read_timeout 30s;
        proxy_next_upstream error timeout http_502 http_503 http_504;

        limit_req zone=ip_rate burst=10 nodelay;

        add_header X-Proxy-Upstream $upstream_addr;
    }

    # Fallback: static 404 for anything else
    location / {
        return 404 'not found';
    }
}
